---
title: 微信小程序开发以及微信小程序大赛总结
date: 2018-06-12 19:05:27
tags: 
- 总结
- wepy
- 微信小程序
categories: 总结
---


## 微信小程序开发

### 关于微信小程序
在开发微信小程序之前, 把文档通读了一遍, 看了下网上关于微信小程序架构的分析.从微信小程序为移动端的各种事件的优化, 基础组件的非常实用属性, wxss中的rpx属性, 小程序的框架等等, 能够看得出来微信团队为了让微信小程序开发(移动端的开发)变得容易做出的一些努力, 但是对于熟悉了web前端开发良好的生态的开发者来说, 微信小程序却让人有些难过, 原本在web开发中的优秀的库都无法使用, 小程序开发的生态暂时非常一般. 尽管有wepy(使用过, 有坑), mpvue(还没使用过), taro(做完比赛之后才发现这个库, 用了比较喜欢的react风格), 但表现得仍然不尽人意, 希望微信小程序越来越好吧.

#### 开发微信小程序中需要注意的地方

1. 微信开发者工具在win10上, map组件中的controller点击之后无效. 当时出现这个问题找了很久bug, 从代码到wepy逐渐排查, 最后发现竟然是开发者工具在win10的问题. 所以在开发微信小程序的时候, 如果你确认你的代码没问题, 在开发者工具上跑不了的时候, 试试手机调试.

2. 使用scroll-view组件的时候, 必须得给他指定height, scrolltoupper事件和scrolltolower事件才能生效.

3. 有map组件存在的页面, 很多css属性是不能生效的, 比如box-shadow. 那么如果想要做成滴滴打车小程序那样的阴影效果该怎么办呢? 使用cover-view和cover-image加载图片来完成hack. 同时需要注意的是, **cover-image不在cover-view里面也是无法生效的**

4. 使用wx.getStorageSync借口获得本地存储的数据, 如果数据在本地中没有, 返回的不是undefined, 而是"", 空字符串.

### 关于wepy
在编写代码的时候进行技术选型, 考虑了wepy和mpvue, 但是因为mpvue是刚开源不久的项目, issue里面的讨论也没有wepy多, 就选择了看起来更加成熟的wepy.

在写wepy的过程中, 也能够看出来wepy做的努力, 感觉是参考了vue和react特性, 从中吸取了两者的优点吧.(写着写着就能感受到react的感觉, 之前没有接触vue, 但是使用wepy的过程中把vue的文档看完了, 可能是情人眼里出西施吧, 越发觉得react的文档组织得比vue好), 但是使用wepy还是有一些需要注意的地方的(可能是受到了微信小程序机制的限制), 以下我将详细说明.

#### wepy中需要注意的地方(坑)
1. wepy对于组件的支持差强人意. 
当你多重嵌套定义组件时, 数据向下层流动很容易出问题.
在下面的示例代码中, child组件在onLoad触发的时候是无法访问到someData的数据的, 这不是最大的问题, 最大的问题是, 从child到descendant, 使用child的props向下传递数据是行不通的, 数据最多从一个组件的data通过子组件的props流向子组件, 无法再从子组件流向子孙组件. wepy这样的行为, 就限制了组件的重复使用, 因为数据流动最多一层(wepy支持使用redux来管理数据, 技术选型的时候, 考虑到队员没有接触过react, vue等框架, 学习wepy本身的学习成本对于队员来说就比较高了, 就没打算使用redux). 假如wepy依旧不能自身对嵌套组件的数据流动等提供良好的支持, 那么依托wepy构建生态我觉得是非常困难的.
{% codeblock 多重嵌套定义组件 lang:javascript %}
// parent.wpy
<templete>
    <view>
        <Child :prop.sync="someData"/>
    </view>
</templete>
<script>
import wepy from "wepy"
import Child from "./child"

export default class Parent extends wepy.component {
    components = {
        Child
    }

    data = {
        someData: "something"
    }
}
</script>

// child.wpy
<templete>
    <view>
        <Descendant :prop.sync="someData"/>
    </view>
</templete>
<script>
import wepy from "wepy"
import Descendant from "./child"

export default class Child extends wepy.component {
    components = {
        Descendant
    }

    props = {
        someData: String
    }
}
</script>

// descendant.wpy
<templete>
    <view>
        <view>\{\{someData}}</view>
    </view>
</templete>
<script>
import wepy from "wepy"

export default class Descendant extends wepy.component {
    props = {
        someData: String
    }
}
</script>
{% endcodeblock %}
解决这个问题没有什么好的办法, redux可能能够解决, 还有就是, 不使用多重嵌套. 我使用wepy的经验告诉我, 最好不要组件套组件, 所有的组件都直接写在page里面, 使用page的data来控制数据流动, 这样的话, 也能解决由于组件生命周期不完全的部分问题. **在wepy中, 组件是没有onShow, onHide的生命周期的**, 所以使用页面来管理数据，是一种比较好的方法,比如下面的例子.
{% codeblock wepy较好的实践 lang:javascript %}
// index.wpy
<templete>
    <view>
        <Child1 :prop.sync="message1" :onTap="onTap1"/>
        <Child2 :prop.sync="message2" :onTap="onTap2"/>
        <Child3 :prop.sync="message3" :onTap="onTap3"/>
    </view>
</templete>
<script>
import wepy from "wepy"
import Child from "./child"

export default class Index extends wepy.page {
    components = {
        Child1: Child,
        Child2: Child,
        Child3: Child
    }

    data = {
        message1: "",
        message2: "",
        message3: "",
        onTap1: (event) => {
            this.message1 = "1"            
            this.$apply()
        },
        onTap2: (event) => {
            this.message2 = "2"
            this.$apply()
        },
        onTap3: (event) => {
            this.message3 = "3"
            this.$apply()
        },
        timer: ""
    }

    onShow: () => {
        this.timer = setInterval(() => {
            wx.request({
                url: "example.com",
                success: (res) => {
                    this.message1 = res.data[1]
                    this.message2 = res.data[2]
                    this.message3 = res.data[3]
                    this.$apply()
                }
            })
        }, 3000)
        this.$apply()
    }

    onHide: () => {
        clearInterval(this.timer)
    }
}
</script>

// child.wpy
<templete>
    <view>
        <view @tap="bindTap">\{\{message}}</view>
    </view>
</templete>
<script>
import wepy from "wepy"
import Descendant from "./child"

export default class Child extends wepy.component {
    components = {
        Descendant
    }

    props = {
        someData: String,
        onTap: Function
    }

    methods = {
        bindTap: (event) => {
            if (this.onTap) {
                this.onTap(event)
            }
        }
    }
}
</script>

{% endcodeblock %}
这个例子中, 使用页面来管理数据, 能够根据页面的隐藏与显示来决定是否请求刷新数据. **同时还有一个要注意的点,就是这个例子中的子组件绑定事件处理函数的方法,从props得到的是数据(函数),是无法直接绑定到事件处理函数的,必须得在methods(注意这里有s)中声明才能绑定,否则是不会起作用的**


2. 编译生成文件过大的问题. wepy编译文件采取的是覆盖的策略, 如果你在源码中删除了一些文件, 编译生成的文件中还是会存在. 如果你想要缩小体积, 删除编译生成的文件, 删除.wepycache后重新编译. 压缩代码时将wepyconfig中的prod改为true就会压缩代码.

3. 编译出错的问题. 在开发者工具的报错的代码中如果发现了生成的代码有未编译的属性, 如.once, .sync, 说明wepy编译出了问题, 后面的编译可能都没有完成. 有时候编译错误实在无法解决的话, 最好的办法是用git回到上一个版本(确实出现过几次非常奇怪的编译错误, 修改来修改去都无法解决, 最后还是回滚代码)

## 微信大赛总结
### 需求与开发的问题
记得之前看<代码大全>的时候, 上面一直提到前期准备的重要性, 当时觉得有点夸张, 现在看来, 在软件开发的时候, 前期准备是非常重要的. 这次比赛我们的需求在后期甚至还有些变动, 整个流程在前期准备时没有形成书面化的文档, 前后端接口的文档也存在部分问题, 以致于前后端对于整个需求的理解不同, 到了后期一直在修改代码. 下次遇到项目时, 可以试着首先就分析需求, 将需求, 业务流程, 前后端接口, 形成完整的书面化的文档, 确定开发者对于业务的需求, 流程到达一致的理解, 最终再进行编写代码, 可能会效果好一点. 同时在设计数据库的时候, 应该要考虑到数据的规模, 提前做好做出优化的准备, 不然到后期进行更改操作数据库的代码也比较麻烦.(<代码大全>有时间还是得看一看)

### 文档与视频
这次比赛做的[视频](https://v.qq.com/x/page/h068154pz45.html)效果还不错, 文档也写的不错(都是队友的功劳), 之前也确实知道这些能够表现出功能的东西还是非常重要的, 但是没有掌握相关的技能, 以后还是得慢慢学习.